Ответы на вопросы теста:

1. Объекты веб-хранилища localStorage и sessionStorage позволяют хранить пары ключ/значение в браузере. Данные, которые в них записаны, сохраняются после обновления страницы (в случае sessionStorage) и даже после перезапуска браузера (при использовании localStorage). 

В отличие от куки, объекты веб-хранилища не отправляются на сервер при каждом запросе. Именно поэтому монжо хранить гораздо больше данных. Большинство современных браузеров могут выделить как минимум 5 мегабайтов данных (или больше), и этот размер можно поменять в настройках. 
Ещё одно отличие от куки – сервер не может манипулировать объектами хранилища через HTTP-заголовки. Всё делается при помощи JavaScript.

Куки хранятся непосредственно в браузере и могут передаваться на сервер.

localStorage - совместно используется между всеми вкладками и окнами с одинаковым источником; «переживает» перезапуск браузера

sessionStorage - разделяется в рамках вкладки браузера, среди ифреймов из того же источника; «переживает» перезагрузку страницы (но не закрытие вкладки)

Т.о. если нужно надолго сохранить много пользовательских данных, то нужен localStorage.

2. Пример как добавить и получить значение из веб-хранилища

localStorage.setItem('login', 'coo')
localStorage.getItem('login')

3. Данные пользователя для сохранения:
1) пароли пользователя локально на компьютере
2) комментарии чата на сервере
3) гугл докс на сервере
4) адрес при заказе в онлайн магазине на компьютере

4. валидация кредитки
пример js (в html кнопку и инпут с соотвествующими id)

function checkCreditCard() {
    let creditCard = document.getElementById('creditCard')
    let creditFormat = /^\b[3-6]\d{3}[ \-_.]?(\d{4}[ \-_.]?){2}\d{4}\b$/
    if (!creditCard.value.match(creditFormat) ) {
        console.log(('Формат кредитной карты неверное указан'))
    } else {
        console.log(('Ваша карта прошла проверку'))
    }
}

document.querySelector('#button').addEventListener('click', checkCreditCard)

5. Input только с числами

1) <input type = "number">
2) html:
    <input type="text">
    <button onclick="typeMe()"></button>
    <div id="message"></div>    

    js:

    function typeMe() {
        if (!Number(document.querySelector('input').value)) {
            document.querySelector('input').value = 'это не число'
        }
    }

3) function typeMe() {
    let input = document.querySelector('input')
    let inputFormat = /^[1-9]+[0-9]*$/
    if (!input.value.match(inputFormat)) {
        document.querySelector('input').value = 'это не число'
    } else {
        document.querySelector('input').value = 'спасибо, это число'
    }
}

6. Регулярка для ФИО
^[а-яА-ЯёЁa-zA-Z]+ [а-яА-ЯёЁa-zA-Z]+ ?[а-яА-ЯёЁa-zA-Z]+$

7. Невалидное поле или, если введены неккоррекные данные, можно поле ввода красным подсветить через css (добавить :invalid для невалдиного поля, через js добавить класс .incorrect по нажатию кнопки)/ в placeholder (атрибут) дать подсказку или в отдельном div


8. Недостатки у стандартного способа задания валидации через HTML5
1) Ограниченность. Проверять можно только факт заполнения, но не корректность введенных данных. 
2) стили применяются до того, как пользователь начнёт работу с формой. Поля, обязательные для заполнения, сразу подсветятся нам как :invalid, а необязательные — как :valid. Это значит, что пользователь, даже не приступив к заполнению формы, может сразу же получить негативную обратную связь и запутаться